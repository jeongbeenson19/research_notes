---
tags: [algorithm, graph, shortest-path, dynamic-programming]
aliases: [플로이드-워셜, Floyd-Warshall]
---

# 플로이드-워셜 (Floyd-Warshall) 알고리즘

플로이드-워셜 알고리즘은 그래프에서 **모든 정점 쌍(All-Pairs)** 간의 최단 경로를 찾는 알고리즘입니다. 다익스트라(Dijkstra) 알고리즘이 하나의 시작 정점에서 다른 모든 정점까지의 최단 경로를 찾는 것과 달리, 플로이드-워셜은 모든 가능한 시작점과 끝점 조합에 대한 최단 거리를 한 번에 계산합니다.

이 알고리즘의 핵심 아이디어는 **동적 계획법(Dynamic Programming)** 에 기반합니다.

---

### **1. 핵심 원리**

플로이드-워셜은 "**어떤 정점 `i`에서 `j`로 가는 최단 경로는, 중간에 특정 경유지 `k`를 거쳐 가는 경로와 거쳐 가지 않는 경로 중 더 짧은 경로이다**"라는 간단한 원리를 반복적으로 적용합니다.

알고리즘은 다음과 같은 점화식을 기반으로 동작합니다.

`D[i][j] = min(D[i][j], D[i][k] + D[k][j])`

-   `D[i][j]`: 정점 `i`에서 `j`까지의 최단 거리
-   `k`: 현재 고려하고 있는 경유지 정점

즉, `i`에서 `j`로 바로 가는 기존의 최단 거리와, `i`에서 `k`를 거쳐 `j`로 가는 새로운 경로의 거리를 비교하여 더 작은 값으로 최단 거리 테이블을 계속해서 갱신하는 것입니다.

---

### **2. 알고리즘 수행 과정**

1.  **거리 테이블 초기화**: 2차원 배열 `D`를 생성하고 다음과 같이 초기화합니다.
    -   `D[i][i] = 0` (자기 자신으로 가는 거리는 0)
    -   `D[i][j] = weight(i, j)` (두 정점 `i`, `j`가 직접 연결된 경우, 간선의 가중치)
    -   `D[i][j] = ∞` (두 정점 `i`, `j`가 직접 연결되지 않은 경우, 무한대 값)

2.  **경유지 기반 갱신**: 3중 반복문을 사용하여 최단 거리 테이블을 갱신합니다.
    -   가장 바깥쪽 반복문은 경유지 `k`를 1부터 N(정점의 수)까지 순회합니다.
    -   중간 반복문은 출발지 `i`를 1부터 N까지 순회합니다.
    -   가장 안쪽 반복문은 도착지 `j`를 1부터 N까지 순회합니다.
    -   각 반복에서 `D[i][j] = min(D[i][j], D[i][k] + D[k][j])` 점화식을 수행하여 테이블을 갱신합니다.

3.  **완료**: 모든 경유지 `k`에 대한 순회가 끝나면, 테이블 `D`에는 모든 정점 쌍 간의 최단 거리가 저장됩니다.

---

### **3. Python3 구현**

```python
import sys

# 무한대 값 설정
INF = float('inf')

# 정점의 수와 간선의 수 입력
# 예시: n, m = 4, 7
n = 4
m = 7

# 2차원 최단 거리 테이블 초기화
distance = [[INF] * (n + 1) for _ in range(n + 1)]

# 자기 자신으로 가는 거리는 0으로 초기화
for i in range(1, n + 1):
    distance[i][i] = 0

# 간선 정보 입력 (예시)
# (출발, 도착, 비용)
edges = [
    (1, 2, 4), (1, 4, 6), (2, 1, 3), 
    (2, 3, 7), (3, 1, 5), (3, 4, 4), (4, 3, 2)
]

for start, end, cost in edges:
    distance[start][end] = cost

# 플로이드-워셜 알고리즘 수행
for k in range(1, n + 1):      # 경유지
    for i in range(1, n + 1):  # 출발지
        for j in range(1, n + 1):  # 도착지
            # i->j 와 i->k->j 경로 비교
            distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])

# 결과 출력
for i in range(1, n + 1):
    for j in range(1, n + 1):
        if distance[i][j] == INF:
            print("INF", end=" ")
        else:
            print(distance[i][j], end=" ")
    print()

# 출력 결과:
# 0 4 8 8 
# 3 0 7 7 
# 5 9 0 4 
# 7 11 2 0 
```

---

### **4. 특징 및 시간 복잡도**

-   **시간 복잡도**: **O(V³)**
    -   정점의 개수 V에 대해 3중 반복문을 사용하므로, V가 클 경우 매우 느려질 수 있습니다. (보통 V가 500 이하일 때 사용 가능)
-   **공간 복잡도**: **O(V²)**
    -   모든 정점 쌍 간의 거리를 저장할 2차원 배열이 필요합니다.
-   **음수 가중치 간선**: 다익스트라와 달리 **음수 가중치 간선이 있어도 사용 가능**합니다. 
-   **음수 사이클 판별**: 만약 알고리즘 수행 후 `distance[i][i]`가 0보다 작은 값(음수)이 된다면, 이는 정점 `i`를 포함하는 **음수 사이클이 존재**함을 의미합니다. `i`에서 출발하여 `i`로 돌아오는 경로의 비용이 음수라는 뜻이기 때문입니다.

### **5. 언제 사용하는가?**

-   그래프의 크기(정점 수)가 작을 때
-   모든 정점에서 다른 모든 정점으로 가는 최단 경로를 구해야 할 때
-   음수 가중치가 포함된 그래프에서 최단 경로를 찾아야 할 때

다익스트라 알고리즘을 모든 정점에 대해 V번 반복하는 것(O(E log V) 또는 O(V²))과 비교하여, 그래프가 **밀집 그래프(Dense Graph)** 이고 구현의 간결함이 중요할 때 플로이드-워셜이 유용할 수 있습니다.

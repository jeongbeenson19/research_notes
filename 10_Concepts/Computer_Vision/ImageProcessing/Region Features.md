
## 🔍 1. 영역 특징(Region Features)이란?

"영역 특징"은 이미지의 특정 부분(영역, region)에서 추출한 시각적 정보입니다. 이 특징은 이미지의 내용(색, 모양, 질감, 경계 등)을 수치화하여 표현한 것으로, 예를 들어 다음과 같은 경우에 사용됩니다:

- SIFT, HOG, ORB 등의 고전적 특징 추출기
    
- CNN의 중간 계층에서 나오는 지역 feature map
    
- Object detection에서 bounding box 내 feature
    

---

## 🔐 2. 불변성(Invariance)이란?

### 👉 정의:

특징이 **어떤 변화(변환, 노이즈 등)가 있어도 거의 변하지 않는 성질**입니다.

### ✅ 예시:

- 회전이 되어도 같은 물체임을 인식하는 것
    
- 조명이 바뀌어도 같은 객체를 인식하는 것
    
- 크기가 달라져도(스케일) 여전히 같은 물체임을 파악
    

### 🔧 주요 불변성 종류:

|변환 유형|설명|예시|
|---|---|---|
|**이동 불변성 (Translation Invariance)**|물체가 위치만 바뀌어도 동일하게 인식|CNN의 pooling layer|
|**회전 불변성 (Rotation Invariance)**|이미지가 회전돼도 같은 객체로 인식|SIFT, 데이터 증강|
|**크기 불변성 (Scale Invariance)**|객체의 크기가 달라도 인식 가능|SIFT, multi-scale CNN|
|**조명 불변성 (Illumination Invariance)**|밝기/명암 변화에도 견디는 특성|LBP, 정규화된 histogram|

### 🧠 중요 이유:

- **실세계 환경은 다양하게 변화**하기 때문에 robust한 시스템 구축에 필수
    
- 같은 객체라도 각도·조명·위치가 다를 수 있으므로, **일관된 특징 표현이 필요**
    

---

## 🎭 3. 가변성(Variance)이란?

### 👉 정의:

특징이 **어떤 변화에 민감하게 반응하는 성질**입니다. 즉, 변화가 있으면 특징도 달라집니다.

### ✅ 예시:

- 사람의 얼굴 표정이 달라지면 다른 특징으로 인식
    
- 고양이와 강아지를 구분하기 위해서는 형태의 차이에 민감해야 함
    

### 🤔 왜 필요한가?

- **클래스 간 구분**을 위해 중요함. 서로 다른 객체는 다른 특징을 가져야 함
    
- 너무 불변적이면, 서로 다른 객체도 같은 특징으로 매칭될 수 있음 (→ over-invariant)
    

---

## ⚖️ 4. 불변성과 가변성의 균형

이 둘은 **trade-off** 관계입니다:

|상황|요구되는 성질|
|---|---|
|동일 객체 추적/인식|높은 불변성|
|객체 분류 (고양이 vs 개)|충분한 가변성|
|영상 정합, 이미지 검색|불변성과 구분 가능한 가변성 모두 중요|

### 🎯 실전 예시:

- CNN은 초기 layer에서 주로 **가변성 높은 특징** (에지, 텍스처 등)을 추출
    
- 깊은 layer로 갈수록 **불변성 높은 특징** (추상적 개념, 클래스 정보 등)을 학습함
    

---

## 📚 결론 요약:

|항목|불변성|가변성|
|---|---|---|
|정의|변화에도 특징이 일정함|변화에 따라 특징이 달라짐|
|역할|견고한 인식, 추적|클래스 간 구분|
|예시|회전/조명 불변|고양이 vs 개 구분|
|기술|SIFT, pooling, normalization|CNN의 shallow layer, attention|

---

## ✅ 1. 영역의 모멘트 (Region Moments)

### 📌 정의:

**모멘트(moment)** 란, **픽셀 값의 공간 분포에 대한 통계적 측정값**이야.  
이미지에서 **모양, 중심, 방향, 면적** 등의 정보를 수치화할 수 있어.

### 🧮 수학적 정의:

이산 이미지의 **$(p, q)$차 모멘트**는 다음과 같아:

$$M_{pq} = \sum_{x} \sum_{y} x^p y^q f(x, y)$$

- $f(x, y)$: $(x, y)$ 좌표의 픽셀 값 (이진 이미지일 경우 0 또는 1)
    
- $p, q$: 모멘트의 차수
    

---

## ✅ 1. 모멘트의 차수란?

모멘트는 보통 다음과 같이 표현돼:

$$M_{pq} = \sum_x \sum_y x^p y^q f(x, y)$$

여기서 $p$와 $q$는 각각 **$x, y$ 방향의 차수**를 의미해.  
이때 **총 차수(order)** 는 단순히 $p + q$로 계산해.

---

### 📌 예시

| $M_{pq}$ | x의 차수 $p$ | y의 차수 $q$ | 총 차수 $p + q$ | 의미                |
| -------- | --------- | --------- | ------------ | ----------------- |
| $M_{00}$ | 0         | 0         | 0차           | 면적                |
| $M_{10}$ | 1         | 0         | 1차           | x 방향 중심 계산용       |
| $M_{01}$ | 0         | 1         | 1차           | y 방향 중심 계산용       |
| $M_{11}$ | 1         | 1         | 2차           | x, y 방향의 상관성      |
| $M_{20}$ | 2         | 0         | 2차           | x 방향 분산(퍼짐)       |
| $M_{02}$ | 0         | 2         | 2차           | y 방향 분산(퍼짐)       |
| $M_{30}$ | 3         | 0         | 3차           | 왜도(skewness) 분석 등 |

---

## ✅ 2. 차수가 높아지면?

- 차수가 높을수록, **이미지의 더 미세한 모양 특성**을 반영
    
- 하지만 **노이즈에 민감**해짐 (높은 차수 모멘트는 잘 안 쓰는 경우도 많아)
    

---

## ✅ 3. 중심 모멘트의 차수도 마찬가지

중심 모멘트 $\mu_{pq}$ 도 마찬가지로,

$$\mu_{pq} = \sum_x \sum_y (x - \bar{x})^p (y - \bar{y})^q f(x, y)$$

여기서도 **차수 = $p + q$** 로 동일하게 정의돼.

---

## 🔑 요약

- **모멘트의 차수 = x 지수 $p$ + y 지수 $q$**
    
- 차수가 높을수록 세밀한 정보 → 하지만 민감함도 커짐
    
- 일반적으로는 0~3차까지만 실무에서 많이 사용됨
    
### 📊 주요 모멘트 종류

| 종류                        | 설명                                                                    | 계산식 / 의미                                                             |
| ------------------------- | --------------------------------------------------------------------- | -------------------------------------------------------------------- |
| **영역 면적**                 | $$M_{00}$$                                                            | 픽셀의 총합 (이진 이미지에선 객체의 면적)                                             |
| **중심좌표 (Centroid)**       | $$ \bar{x} = \frac{M_{10}}{M_{00}}, \bar{y} = \frac{M_{01}}{M_{00}}$$ | 무게 중심                                                                |
| **중심 모멘트** ($\mu_{pq}$)   | 중심 기준으로 측정                                                            | $$\mu_{pq} = \sum_x \sum_y (x - \bar{x})^p (y - \bar{y})^q f(x, y)$$ |
| **정규화 모멘트** ($\eta_{pq}$) | 스케일 불변성 부여                                                            | $$\eta_{pq} = \mu_{pq} / \mu_{00}^{(1 + \frac{p + q}{2})}$$          |
| **Hu 모멘트 (Hu Moments)**   | 7개의 회전, 이동, 크기 불변한 값                                                  | Hu가 정리한 비선형 조합 (패턴 인식에 유용)                                           |
| 열 분산                      | 화소들이 수직 방향으로 퍼진 정도                                                    | $$v_{cc}=\frac{\mu_{20}}{M_{00}}$$                                   |
| 행 분산                      | 화소들이 수평 방향으로 퍼진 정도                                                    | $$v_{rr}=\frac{\mu_{02}}{M_{00}}$$                                   |
| 열행 분산                     | 보통 **형태의 기울기**나 **대각선 대칭성**, 또는 **회전 중심과 관련된 통계량**을 의미                | $$v_{rc}=\frac{\mu_{11}}{M_{00}}$$                                   |


## 🔷 1. $M_{00}$이란 무엇인가?

$$M_{00} = \sum_x \sum_y f(x, y)$$

여기서

- $f(x, y)$는 **해당 위치의 픽셀 값**을 의미해
    
- 이 값이 **0 또는 1 (이진 이미지)**일 경우,  
    즉 **객체는 1, 배경은 0**이라면:
    

$M_{00} = \sum_{\text{객체 픽셀만}} 1 = \text{객체의 픽셀 수} = \text{면적}$

✔️ 즉, **객체에 해당하는 픽셀의 총 개수 = 면적**이라는 아주 단순한 논리야!

---

## 🔶 2. 면적 = 넓이를 구성하는 픽셀들의 수

이미지는 결국 "픽셀 격자(grid)"잖아.  
이 격자에서 **1×1 크기의 정사각형**들이 모여 있는 셈이야.

그래서 면적은 그냥:

객체에 해당하는 픽셀 개수×각 픽셀의 면적\text{객체에 해당하는 픽셀 개수} \times \text{각 픽셀의 면적}

근데 보통 **픽셀 면적 = 1로 가정**하니까,  
결국 면적 = 픽셀 개수가 되는 거지.

---

### 📌 예시

```plaintext
Binary Image (5x5):

0 0 1 0 0  
0 1 1 1 0  
0 0 1 0 0  
```

이 이미지에서 객체 픽셀 값이 1인 부분만 세어보면:  
→ 총 5개

그래서

$$M_{00} = 5 = \text{면적}$$

---

## 🔷 3. 그럼 회색조 이미지일 땐?

회색조나 컬러 이미지에서는 $f(x, y) \in [0, 255]$이야.  
이 경우 $M_{00}$은 "총 밝기 합" 혹은 "질량" 같은 개념으로 사용됨.  
즉, **픽셀 값 자체를 "무게"로 간주**해서 면적 대신 **총 에너지 or 질량**을 표현할 수 있어.

---

## 🔶 4. 연속적인 함수일 경우에도 성립?

연속 함수로 표현하면 다음과 같은 적분으로 표현돼:

$$M_{00} = \iint_R f(x, y) \, dx\,dy$$

이건 **2차원 면적 적분**이야.

- $f(x, y) = 1$이면 → 그냥 면적 계산
    
- $f(x, y) \ne 1$이면 → 질량, 밝기합 등으로 해석
    

---

## ✅ 최종 요약

| 항목                      | 의미                     |
| ----------------------- | ---------------------- |
| $M_{00} = \sum f(x, y)$ | 이미지에서 **0차 모멘트**       |
| 이진 이미지일 경우              | **객체에 해당하는 픽셀 수 = 면적** |
| 회색조일 경우                 | **총 밝기 or 총 질량**의 개념   |
| 연속 함수일 경우               | **2D 면적 적분**으로 확장 가능   |

---

## 🌀 2. 모양 특징 (Shape Features)

모양 특징은 객체의 **윤곽(contour)** 또는 **바이너리 마스크**를 기반으로 정의돼. 객체의 **형태를 정량화**할 수 있는 수치들이야.

### 🌟 대표적인 모양 특징들

| 특징                          | 설명             | 수식/설명                                              |
| --------------------------- | -------------- | -------------------------------------------------- |
| **면적 (Area)**               | 픽셀 개수          | $A = M_{00}$                                       |
| **둘레 (Perimeter)**          | 경계선의 길이        | `cv2.arcLength()`로 계산                              |
| **경계 박스 (Bounding Box)**    | 객체 외접 사각형      | 최소 사각형 또는 회전 박스                                    |
| **윤곽 중심 (Centroid)**        | 무게 중심          | $(\bar{x}, \bar{y})$                               |
| **세로/가로 길이 (Height/Width)** | 박스 크기          | `boundingRect()`                                   |
| **종횡비 (Aspect Ratio)**      | 가로/세로 비율       | w / h                                              |
| **모양률 (Extent)**            | 영역/바운딩 박스 비율   | $\text{Area} / (w \cdot h)$                        |
| **밀도 (Solidity)**           | 볼록 껍질 기준 밀도    | $\text{Area} / \text{Convex Hull Area}$            |
| **이심률 (Eccentricity)**      | 타원 근사 시 중심의 편심 | 타원 장축/단축 비                                         |
| **원형도 (Circularity)**       | 얼마나 원에 가까운지    | $\pi \cdot \frac{\text{Area}}{\text{Perimeter}^2}$ |
| **Orientation**             | 객체가 기울어진 각도    | 2차 중심 모멘트로 계산                                      |
#### 둘레

$$
p = n_{\text{even}}+n_{\text{odd}}\sqrt{2}
$$

#### 둥근 정도

$$
r = \frac{4\pi a}{p^2}
$$
#### 주축의 방향
$$
\theta = \frac{1}{2}\arctan \left( \frac{2\mu_{11}}{\mu_{20}-\mu_{02}} \right)
$$
### 📌 타원 근사 기반 특징 (Orientation, Eccentricity 등)

타원으로 근사하면 **회전 방향, 장단축, 기울기** 등을 얻을 수 있어.  
→ `cv2.fitEllipse()` 사용

---

## 📦 실전 예: OpenCV에서 모멘트와 모양 특징 계산하기

```python
import cv2
import numpy as np

img = cv2.imread('binary_image.png', 0)
_, binary = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)

# 윤곽 추출
contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
cnt = contours[0]

# 모멘트
M = cv2.moments(cnt)
cx = int(M['m10'] / M['m00'])  # 중심 x
cy = int(M['m01'] / M['m00'])  # 중심 y

# 면적과 둘레
area = cv2.contourArea(cnt)
perimeter = cv2.arcLength(cnt, True)

# 경계 박스 및 종횡비
x, y, w, h = cv2.boundingRect(cnt)
aspect_ratio = float(w) / h

# 모양률과 밀도
extent = area / (w * h)
hull = cv2.convexHull(cnt)
solidity = float(area) / cv2.contourArea(hull)

# 타원 근사
ellipse = cv2.fitEllipse(cnt)
angle = ellipse[2]
```

---

## 🎯 요약

|구분|설명|예시 용도|
|---|---|---|
|**모멘트**|공간 분포를 수치화|중심, 방향, 크기, Hu invariant|
|**모양 특징**|객체의 형태를 수치로 표현|검출기, 분류기, 비교기 입력값|

---

## ✅ 텍스처란?

> **"텍스처"** 는 영상에서 **밝기(intensity)의 국소적이고 반복적인 변동 패턴**을 말해.  
> 보통 **결, 결 방향성, 거칠기, 반복성, 불규칙성** 등을 포함해.

---

## 📌 주요 텍스처 특징 추출 방법들

텍스처를 수치적으로 표현하기 위해 여러 가지 기법들이 사용돼. 대표적인 방법들을 정리해줄게:

---

### 1. 💠 **통계적 접근 (Statistical Methods)**

#### 📌 1-1. **GLCM (Gray-Level Co-occurrence Matrix, 회색조 공분산 행렬)**

- 가장 널리 쓰이는 텍스처 특징 추출법 중 하나.
    
- 어떤 두 픽셀이 일정 거리와 방향만큼 떨어져 있을 때, 그 **밝기 조합이 얼마나 자주 나오는지를 기록**함.
    

예시:  
→ "왼쪽 픽셀이 100이고 오른쪽 픽셀이 120일 확률은?"

#### 📊 GLCM에서 추출할 수 있는 대표적인 특징들:

|특징 이름|설명|
|---|---|
|**Contrast**|밝기 차이의 강도 (거칠기)|
|**Correlation**|패턴의 규칙성, 방향성|
|**Energy (ASM)**|텍스처의 균일성 (반복성)|
|**Homogeneity**|중심 대각선 주변에 얼마나 분포해 있는가 (부드러움)|

---

### 2. 🌀 **변환 기반 접근 (Transform-Based)**

#### 📌 2-1. **Gabor 필터**

- 특정 **주파수와 방향**에 민감한 필터.
    
- 마치 인간의 시각 피질처럼 작동해서, 방향성이나 주기성 있는 패턴을 잘 잡아냄.
    

➡ 보통 **여러 방향과 스케일의 Gabor 필터**를 적용해서 반응값의 통계를 특성으로 사용.

#### 📌 2-2. **Wavelet Transform**

- 이미지를 주파수 성분으로 분해해서 텍스처를 분석.
    
- Gabor보다 더 멀티스케일이고 연산 효율이 좋음.
    

---

### 3. 🧩 **Local Binary Pattern (LBP)**

- 중심 픽셀과 주변 픽셀의 **밝기 차이**만 보고 0 또는 1로 인코딩한 이진 패턴.
    
- 회전 불변, 조명 변화에 강함.
    
- 매우 가볍고 계산 효율이 좋아서 실시간 영상 처리에도 사용됨.
    

---

### 4. 🤖 **딥러닝 기반 접근**

#### 📌 CNN Feature Maps

- 합성곱 신경망(CNN)의 **중간 계층에서 추출된 특성 맵**은 일반적으로 텍스처 정보에 민감함.
    
- 특히 **VGG, ResNet** 등의 네트워크에서 Conv layer 출력값을 "딥 텍스처 특성"으로 사용 가능.
    

---

## 🔍 텍스처 특징이 사용되는 예시

|분야|설명|
|---|---|
|영상 분할|서로 다른 텍스처 영역 구분 (예: 바다 vs 산)|
|물체 인식|표면 특성으로 물체 구분 (예: 고양이 털 vs 카펫)|
|의료 영상|조직의 섬유 구조, 종양 검출|
|위조 지폐 감별|지폐의 질감 패턴 판별|

---

## ✅ 정리 요약

|방식|핵심 개념|장점|예|
|---|---|---|---|
|GLCM|픽셀쌍 밝기 통계|직관적, 다재다능|Contrast, Homogeneity|
|Gabor|방향성 + 주파수 민감|인간 시각 유사, 방향감지|방향별 특징|
|LBP|국소 이진 패턴|빠름, 조명 강건|실시간 감시|
|Wavelet|다중 해상도 분해|멀티스케일 분석|텍스처 압축|
|CNN|학습된 표현|강력, 고수준|ResNet, VGG|

### 프로그램 4-8: 이진 영역의 특징을 추출하는 함수 사용하기
```python
import skimage
import numpy as np
import cv2 as cv

# 🐴 1. Horse 이미지 불러오기 (Binary Mask 형태: 배경은 False, 말의 실루엣은 True)
orig = skimage.data.horse()

# 🔄 2. skimage의 Binary 이미지(True/False)를 0~255 정수형 이미지로 변환 (True→255, False→0)
#     동시에 색 반전시킴 (흰 배경, 검은 말 → 검은 배경, 흰 말) → OpenCV가 하얀색(255)을 객체로 인식
img = 255 - np.uint8(orig) * 255

# 👀 3. 변환된 이미지 확인
cv.imshow('Horse', img)

# 🧱 4. 외곽선 추출
#     - cv.RETR_EXTERNAL: 가장 바깥 외곽선만 추출 (속이 빈 도형 등 내부는 무시)
#     - cv.CHAIN_APPROX_NONE: 외곽선의 모든 점을 저장
contours, hierarchy = cv.findContours(img, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_NONE)

# 🎨 5. 원본 이미지에 외곽선 시각화용 복사본 생성 (Gray → Color로 변환)
img2 = cv.cvtColor(img, cv.COLOR_GRAY2BGR)

# 💡 6. 외곽선 그리기 (핑크색: (255, 0, 255))
cv.drawContours(img2, contours, -1, (255, 0, 255), 2)
cv.imshow('Horse with contour', img2)

# 🔍 7. 첫 번째 외곽선을 분석 대상으로 사용
contour = contours[0]

# 📊 8. 모멘트 계산 (0~3차의 공간 모멘트와 중심화 모멘트 등)
m = cv.moments(contour)

# 📏 9. 면적 계산 (픽셀 단위)
area = cv.contourArea(contour)

# 🎯 10. 중심점 계산 (무게중심): m10/m00, m01/m00
cx, cy = m['m10'] / m['m00'], m['m01'] / m['m00']

# 📐 11. 둘레(윤곽선 길이) 계산
perimeter = cv.arcLength(contour, True)  # True = 폐곡선 여부

# ⚪ 12. 둥근 정도(Roundness, 원형성 지표) 계산
#     - 1에 가까울수록 원형, 작을수록 날카로운 형태
roundness = (4.0 * np.pi * area) / (perimeter * perimeter)

# 🖨️ 13. 결과 출력
print('면적 =', area,
      "\n중점 = (", cx, ',', cy, ")",
      '\n둘레 =', perimeter,
      '\n둥근 정도 =', roundness)

# 🎨 14. 다시 이미지 복사하여 도형 근사 및 볼록 껍질 시각화용
img3 = cv.cvtColor(img, cv.COLOR_GRAY2BGR)

# 🔻 15. 다각형 근사화 (윤곽선을 직선으로 근사)
#     - epsilon: 근사 정확도 (값이 클수록 단순화됨)
contour_approx = cv.approxPolyDP(contour, 8, True)
cv.drawContours(img3, [contour_approx], -1, (0, 255, 0), 2)  # 초록색

# 🔺 16. 볼록 껍질(Convex Hull) 계산
#     - 윤곽을 둘러싼 가장 작은 볼록 다각형
hull = cv.convexHull(contour)

# 🔁 17. drawContours를 위해 차원 재정렬
hull = hull.reshape(1, hull.shape[0], hull.shape[2])
cv.drawContours(img3, hull, -1, (0, 0, 255), 2)  # 빨간색

# 👁️ 18. 최종 결과 확인 (근사 다각형 + 볼록 껍질)
cv.imshow('Horse with line segments and convex hull', img3)

# 🛑 19. 키 입력 대기 및 종료
cv.waitKey()
cv.destroyAllWindows()

```
